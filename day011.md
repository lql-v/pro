## 再次解决包头问题
思想是在客户端发送前加入魔数 数据大小的包头
因此发出的包为
| magicnaum | datalen | data |
客户端发送的数据默认以4096字节触发一次read_cb，此时第一次触发read_cb是len字节（4096），此时比较datalen > 4096 字节，说明此时不应该直接触发read_cb，应该继续接受datalen字节数据后再触发，因此通过bufferevent_setwatermark(bev, EV_READ, datalen, 0); 把触发低水位设置为datalen，即设置数据到达datalen再触发read_cb，此时就能读出所有的数据

```cpp
// 获取输入缓冲区
struct evbuffer *evbuf = bufferevent_get_input(bev);
// 读取缓冲区有数据的大小
size_t len = evbuffer_get_length(evbuf);
// 数据量小于8 不对劲直接返回
if(len < 8) return;

// 读出前8个字节
char head[9];
evbuffer_copyout(evbuf, head, 8);
uint32_t magic = ntohl(*(uint32_t *)head);
uint32_t datalen = ntohl(*(uint32_t *)(head + 4));

// 魔数比较
if(magic == 17171717)
{   
    // 接受数据还不足以处理
    if(datalen + 8 > len)
    {   
        bufferevent_setwatermark(bev, EV_READ, len , 0);
        return;
    }
    // 接受数据足够
    else
    {        
        evbuffer_drain(evbuf, 8);
        len -= 8;
        bufferevent_setwatermark(bev, EV_READ, 0, 0);
        std::string rec;
        while(len > 0)
        {   
            char buf[4096];
            int size = (len <= 4096) ? len : 4096;
            // 读取并丢弃数据
            bufferevent_read(bev, buf, size);
            rec.append(buf, size);
            len -= size;
        }
        // 创建需求管理器
        spdlog::default_logger()->debug("接受到消息大小：{}", rec.size());
        RequestMgr reqmgr(bev, rec);
        // 解析需求并执行相应函数
        reqmgr.process();
        return;
    }
}     
else
{
    evbuffer_drain(evbuf, len);
    return;
}  
```

## 客户端与服务端断开连接或发生错误的服务端处理
绑定回调函数
```cpp
bufferevent_setcb(bev, read_cb, write_cb, event_cb, nullptr);
```
bufferevent_setcb的第四个参数即为事件的断联错误处理回调函数，它的函数形式如下
```cpp
/**
 * @brief 异常处理函数
 * @param[in] bev 事件集
 * @param[in] what 发生事件的类型
 * @param[in] arg 设置回调函数时的参数
 */
void event_cb(bufferevent *bev, short what, void *arg);
```