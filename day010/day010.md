## 解决分包问题
只要不直接读出缓冲区的数据，等到下次再读取即可一次性读出所有数据。\
```CPP
struct evbuffer *evbuf = bufferevent_get_input(bev);
size_t len = evbuffer_get_length(evbuf);
if(len % 4096 == 0) return;
std::string rec;
while(len > 0)
{   
    spdlog::default_logger()->debug("读, {} ", len);
    char buf[4096];
    int size = (len<=4096) ? len : 4096;
    // 读取并丢弃数据
    bufferevent_read(bev, buf, size);
    rec.append(buf, size);
    len -= size;
}
// 检查后四位是否是特殊符号
if( (rec.substr(rec.length()-4)) == "/EOF")
{
    rec.erase(rec.length() - 4);
}
// evbuffer_free(evbuf);
// 创建需求管理器
spdlog::default_logger()->debug("接受到消息大小：{}", rec.size());
RequestMgr reqmgr(bev, rec);
// 解析需求并执行相应函数
reqmgr.process();
return;
// 可行
```

## Qt显示图片
Qt直接读取二进制数据文件，并将该图片展示
```cpp
QByteArray byteArray = str.toUtf8(); // 转换为 UTF-8 编码的字节数组
QPixmap pixmap;
pixmap.loadFromData(imageData);
QLabel *label = new QLabel(MainWindow);
label.setPixmap(pixmap);
label.show()
```

## Qt图片aes128加密
使用qaesencryption库进行加密
```cpp
#include "qaesencryption.h"
// 用aes128加密
QByteArray key ("FileStoreService");
QAESEncryption aesEncryption(QAESEncryption::AES_128, QAESEncryption::CBC);
QByteArray encryptedData = aesEncryption.encode(imageData, key, key);

```

